# -*- coding: utf-8 -*-
"""
/***************************************************************************
 HeatNetTool
                                 A QGIS plugin
 This plugin provides tools for district heating planning
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-03-04
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Lars Goray
        email                : lars.goray@fh-muenster.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QCompleter, QMessageBox
from qgis.core import Qgis, QgsField, QgsProject, QgsMapLayer, QgsVectorLayer, QgsMessageLog, QgsLayerTreeLayer

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .heat_net_tool_dialog import HeatNetToolDialog

import os.path
import subprocess
import sys
import re
from pathlib import Path

try:
    import pandas as pd
    import geopandas as gpd
    from shapely import Point
    from .src.download_files import file_list_from_URL, search_filename, read_file_from_zip, filter_df, get_shape_from_wfs
    from .src.adjust_files import Streets_adj, Buildings_adj, Parcels_adj, spatial_join
    from .src.status_analysis import WLD, Polygons
    from .src.net_analysis import Streets, Source, Buildings, Graph, Net, Result, get_closest_point, calculate_GLF, calculate_volumeflow, calculate_diameter_velocity_loss
    from .src.load_curve import Temperature, LoadProfile, safe_in_excel
    from workalendar.europe import Germany
except:
    pass

class HeatNetTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'HeatNetTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Heat Net Tool ')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Gemarkung (Name and info of municipalities and cities in NRW)
        self.gemarkungen_df = pd.DataFrame()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('HeatNetTool', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/heat_net_tool/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Toolbox for planning district heating networks'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Heat Net Tool '),
                action)
            self.iface.removeToolBarIcon(action)

    def install_package(self):
        '''
        Installs Python packages using pip.

        Parameters
        ----------
        package_list : list of str
            List of package names to be installed.

        Returns
        -------
        None
        '''
        # feedback
        self.dlg.intro_label.setText('Starting Installation. Check cmd for progress.')
        self.dlg.intro_label.setStyleSheet("color: orange")
        self.dlg.intro_label.repaint()

        # get requirements
        requirements_path =  self.plugin_dir+'/requirements.txt'
        if not os.path.exists(requirements_path):
            self.dlg.intro_label.setText(f"Error: {requirements_path} not found.")
            self.dlg.intro_label.setStyleSheet("color: red")
            self.dlg.intro_label.repaint()
            
        with open(requirements_path, 'r') as file:
            package_list = [line.strip() for line in file if line.strip()]

        # check if pip is installed
        try:
            import pip
            print("pip ist bereits installiert.")
        except ImportError:
            print("pip ist nicht installiert. Versuche, pip zu installieren...")
            try:
                import ensurepip
                ensurepip.bootstrap()
                print("pip wurde erfolgreich installiert.")
            except Exception as e:
                print(f"Fehler beim Installieren von pip: {e}")

        current_executable = sys.executable
        python_executable = os.path.join(os.path.dirname(current_executable), 'python.exe')

        try:
            # Execute the "pip install" command to install all packages
            cmd = [python_executable, "-m", "pip", "install", "--upgrade"] + package_list
            subprocess.check_call(["cmd", "/K"] + cmd)  # /K ceeps window open
        except subprocess.CalledProcessError as e:
            # feedback
            self.dlg.intro_label.setText(f"Process finished or aborted.")
            self.dlg.intro_label.setStyleSheet("color: white")
            self.dlg.intro_label.repaint()

        # Import all packages
        import pandas as pd
        import geopandas as gpd
        from shapely import Point
        from .src.download_files import file_list_from_URL, search_filename, read_file_from_zip, filter_df, get_shape_from_wfs
        from .src.adjust_files import Streets_adj, Buildings_adj, Parcels_adj, spatial_join
        from .src.status_analysis import WLD, Polygons
        from .src.net_analysis import Streets, Source, Buildings, Graph, Net, Result, get_closest_point, calculate_GLF, calculate_volumeflow, calculate_diameter_velocity_loss
        from .src.load_curve import Temperature, LoadProfile, safe_in_excel
        from workalendar.europe import Germany

    def select_output_file(self, dir, lineEdit, filetype):
        '''
        Opens a file dialog to select an output file and sets the selected path to a QLineEdit.

        Parameters
        ----------
        dir : str
            The directory to start the file dialog in.
        lineEdit : QLineEdit
            The QLineEdit widget to display the selected file path.
        filetype : str
            The file type filter for the dialog (e.g., "*.txt").

        Returns
        -------
        None
        '''
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select output file ",dir, filetype)
        lineEdit.setText(filename)
    
    def select_input_file(self, dir, lineEdit, filetype):
        '''
        Opens a file dialog to select an input file and sets the selected path to a QLineEdit.

        Parameters
        ----------
        dir : str
            The directory to start the file dialog in.
        lineEdit : QLineEdit
            The QLineEdit widget to display the selected file path.
        filetype : str
            The file type filter for the dialog (e.g., "*.txt").

        Returns
        -------
        None
        '''
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select input file", dir, filetype)
        if filename:  # Check if the user selected a file
            lineEdit.setText(filename)

    def get_layer_path_from_combobox(self, combobox):
        '''
        Gets the path of the selected layer from the given ComboBox.

        Parameters
        ----------
        combobox : QComboBox
            The QComboBox object representing the layer selection.

        Returns
        -------
        tuple
            A tuple containing the path of the selected layer (str), the layer name (str), and the selected layer object (QgsVectorLayer). Returns (None, None, None) if no layer is found.
        '''
        # Get the name of the selected layer from the ComboBox
        selected_layer_name = combobox.currentText()
        selected_layer_name = re.sub(r'\s*\[.*?\]', '', selected_layer_name).strip()

        # Find the layer in the project
        layers = QgsProject.instance().mapLayersByName(selected_layer_name)

        if layers:
            # Assume we take the first found layer if multiple layers have the same name
            selected_layer = layers[0]
            # Extract the path from the layer information
            path = selected_layer.source()

            # Check if '|' character exists in the path
            if '|' in path:
                # Split the path and layer name
                path_parts = path.split('|')
                path = path_parts[0]  # Path is the first part
                # Layer name is the second part, remove 'layername='
                selected_layer_name = path_parts[1].replace('layername=', '')

            return path, selected_layer_name, selected_layer
        else:
            return None, None, None

    def create_layer_tree_structure(self):
        '''
        Creates the desired layer tree structure if it does not already exist.

        This function checks if the group 'FHeat' exists in the layer tree. If it does not, it creates the group
        and adds the subgroups 'Basics', 'adjusted', 'status', and 'net' under it. 

        Returns
        -------
        None
        '''
        # Get the root group in the Layer tree
        root = QgsProject.instance().layerTreeRoot()

        # Check if the 'FHeat' group already exists
        fheat_group = root.findGroup('F|Heat')

        if fheat_group is None:
            # Create the 'FHeat' group
            fheat_group = root.addGroup('F|Heat')

            # Define the subgroups
            subgroups = ['Net', 'Heat Density', 'Adjusted Files', 'Basic Data']
            
            # Add each subgroup to 'FHeat'
            for subgroup in subgroups:
                fheat_group.addGroup(subgroup)

    def add_shapefile_to_project(self, shapefile_path, style=None, group_name=None):
        '''
        Adds a shapefile to the QGIS project.

        Parameters
        ----------
        shapefile_path : str
            The file path of the shapefile to add.
        style : str, optional
            The name of the style to apply to the layer. Options include 'hld', 'polygons', 'net', 'streets', 'buildings', 'parcels'.
        group_name : str
            Layer group where the layer should be added

        Returns
        -------
        None
        '''
        layer_name = os.path.splitext(os.path.basename(shapefile_path))[0]
        layer = QgsVectorLayer(path=shapefile_path, baseName=layer_name, providerLib='ogr')
        if not layer.isValid():
            print("Layer failed to load!")
            return

        # Get the root group in the Layer tree
        root = QgsProject.instance().layerTreeRoot()

        if group_name:
            # Check if the group exists
            group = root.findGroup(group_name)
            
            # If the group doesn't exist, create it
            if group is None:
                group = root.addGroup(group_name)
            
            # Add the layer to the specified group
            QgsProject.instance().addMapLayer(layer, False)  # False prevents adding to the top-level group
            group.insertChildNode(0, QgsLayerTreeLayer(layer))  # Add layer to group

        else:
            # If no group is specified, add the layer to the root
            QgsProject.instance().addMapLayer(layer)

        # Apply style
        if style == 'hld':
            style_path = self.plugin_dir + '/layerstyles/hld.qml'
            layer.loadNamedStyle(style_path)

        if style == 'polygons':
            style_path = self.plugin_dir + '/layerstyles/polygons.qml'
            layer.loadNamedStyle(style_path)

        if style == 'net':
            style_path = self.plugin_dir + '/layerstyles/net.qml'
            layer.loadNamedStyle(style_path)

        if style == 'streets':
            style_path = self.plugin_dir + '/layerstyles/streets.qml'
            layer.loadNamedStyle(style_path)

        if style == 'buildings':
            style_path = self.plugin_dir + '/layerstyles/buildings.qml'
            layer.loadNamedStyle(style_path)
        
        if style == 'parcels':
            style_path = self.plugin_dir + '/layerstyles/parcels.qml'
            layer.loadNamedStyle(style_path)

        if style == 'buildings_adj':
            style_path = self.plugin_dir + '/layerstyles/buildings_adj.qml'
            layer.loadNamedStyle(style_path)

        if style == 'streets_adj':
            style_path = self.plugin_dir + '/layerstyles/streets_adj.qml'
            layer.loadNamedStyle(style_path)

    def load_download_options(self):
        '''
        Loads municipality and city names of NRW into comboBoxes.

        This method reads an Excel file containing information about municipalities and cities, and populates comboBoxes with this information.

        Returns
        -------
        None
        '''
        path = Path(self.plugin_dir) / 'data/cities.xlsx'
        df = pd.read_excel(path, dtype={'schluessel': str, 'gmdschl': str})

        # convert string to list with floats
        df['bbox'] = df['bbox'].apply(lambda x: [float(coord) for coord in x.replace('(', '').replace(')', '').split(',')])

        municipalities = sorted(df['gemeinde'].unique().tolist())
        cities = sorted(df['name'].tolist())

        # add options to comboBoxes
        self.dlg.load_comboBox_municipality.addItems(municipalities)
        self.dlg.load_comboBox_city.addItems(cities)

        # save df for later operations
        self.gemarkungen_df = df
    
    def adapt_download_options(self):
        '''
        Adjusts the city ComboBox based on the selected municipality.
        '''
        value = self.dlg.load_comboBox_municipality.currentText()

        # Filter the dataframe based on the selected municipality
        filtered_cities = self.gemarkungen_df[self.gemarkungen_df['gemeinde'] == value]['name'].tolist()

        # Sort the list of cities for the selected municipality (value)
        sorted_cities = sorted(filtered_cities)

        # Clear the city ComboBox
        self.dlg.load_comboBox_city.clear()

        # Add the filtered cities to the city ComboBox
        self.dlg.load_comboBox_city.addItems(sorted_cities)

    # Methods for loading layers and attributes to comboboxes

    def get_all_loaded_layers(self):
        '''
        Get a list of all loaded layers in the project, including layers within groups.

        Returns
        -------
        list of QgsMapLayer
            A list containing all the loaded layers in the current QGIS project.
        '''
        root = QgsProject.instance().layerTreeRoot()
        all_layers = root.layerOrder()
        loaded_layers = []

        for layer in all_layers:
            if isinstance(layer, QgsMapLayer):
                loaded_layers.append(layer)

        return loaded_layers

    def load_layers_to_combobox(self, combobox):
        '''
        Load names of all the loaded layers into a QComboBox.

        Parameters
        ----------
        combobox : QComboBox
            The ComboBox widget to populate with layer names.

        Returns
        -------
        None
        '''
        # Fetch the currently loaded layers
        layers = self.get_all_loaded_layers()
        # Clear the contents of the comboBox from previous runs
        combobox.clear()
        # Add a default translated item as the first item in the ComboBox
        combobox.addItem(self.tr("Select Layer"))
        # Populate the comboBox with names of all the loaded layers
        combobox.addItems([layer.name() for layer in layers])
        # Set the default item as the current index
        combobox.setCurrentIndex(0)
    
    def load_attributes_to_combobox(self, layer_name, combobox):
        '''
        Load attributes of the selected layer into a QComboBox.

        Parameters
        ----------
        layer_name : str
            The name of the layer whose attributes are to be loaded.
        combobox : QComboBox
            The ComboBox widget to populate with attribute names.

        Returns
        -------
        None
        '''
        # Find the layer by its name
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]  # Assuming unique names
        # Clear the contents of the comboBox from previous runs
        combobox.clear()
        # Add a default item as the first item in the ComboBox
        combobox.addItem(self.tr("Select Attribute"))
        # Populate the comboBox with names of all the attributes of the layer
        for field in layer.fields():
            combobox.addItem(field.name())

        # Set the default item as the current index
        combobox.setCurrentIndex(0)

    def load_attributes(self, combobox_in, combobox_out):
        '''
        Load attributes of the layer selected in one combobox into another combobox.

        Parameters
        ----------
        combobox_in : str
            The name of the ComboBox widget containing the layer selection.
        combobox_out : str
            The name of the ComboBox widget to populate with attribute names.

        Returns
        -------
        None
        '''
        # Get the current layer name selected in the specified combobox
        layer_name_with_epsg = getattr(self.dlg, combobox_in).currentText()

        # Use a regular expression to strip out the EPSG code (or anything in brackets)
        layer_name = re.sub(r'\s*\[.*?\]', '', layer_name_with_epsg).strip()

        layers = self.get_all_loaded_layers()

        # Load attributes to the specified combobox
        if layer_name in [layer.name() for layer in layers]:
            self.load_attributes_to_combobox(layer_name, getattr(self.dlg, combobox_out))
    
    def tab_change(self):
        '''
        Update ComboBoxes with loaded layers when the tab is changed.

        Returns
        -------
        None
        '''
        # Load layers into comboBoxes
        self.load_layers_to_combobox(self.dlg.adjust_comboBox_buildings)
        self.load_layers_to_combobox(self.dlg.adjust_comboBox_parcels)
        self.load_layers_to_combobox(self.dlg.adjust_comboBox_streets)
        self.load_layers_to_combobox(self.dlg.status_comboBox_streets)
        self.load_layers_to_combobox(self.dlg.status_comboBox_parcels)
        self.load_layers_to_combobox(self.dlg.status_comboBox_buildings)
        self.load_layers_to_combobox(self.dlg.net_comboBox_buildings)
        self.load_layers_to_combobox(self.dlg.net_comboBox_streets)
        self.load_layers_to_combobox(self.dlg.net_comboBox_source)
        self.load_layers_to_combobox(self.dlg.net_comboBox_polygon)

    # Main Methods

    def download_files(self):
        '''
        Downloads and processes shapefiles for buildings, streets, and parcels for a selected city or municipality.

        This function performs the following steps:

        1. **Progress Bar Initialization**:
        - Sets the progress bar to 0, indicating the start of the download and processing operation.

        2. **Determine Selection**:
        - Retrieves the selected city or municipality from the graphical user interface (GUI).
        - Checks whether a city or municipality is selected and sets the appropriate parameter.

        3. **Filter DataFrame**:
        - Filters a DataFrame (`gemarkungen_df`) for the selected city or municipality based on the user’s selection.

        4. **Download Buildings Shapefiles**:
        - Accesses the URL for building data and downloads the relevant shapefiles based on the municipality key.

        5. **Download Streets Shapefiles**:
        - Accesses the URL for street data and downloads the relevant shapefiles based on the municipality key.

        6. **Download Parcel Data**:
        - Accesses a Web Feature Service (WFS) to download parcel data, ensuring that if a city is selected, only the relevant parcels are retrieved.

        7. **Filter Geometries**:
        - If only a city is selected, filters the building and street data to include only geometries that intersect with the selected parcels.

        8. **Save Shapefiles**:
        - Saves the processed building, street, and parcel shapefiles to specified paths.

        9. **Load Shapefiles into GIS Project**:
        - Loads the saved shapefiles into the GIS project, applying appropriate styling.

        10. **Progress and Feedback Updates**:
            - Updates the progress bar throughout the process and provides feedback in the GUI about the current status, ending with a completion message.

        Parameters
        ----------
        None

        Returns
        -------
        None
        '''
        # Note: In GUI city = district, municipality = city

        # update progressBar
        self.dlg.load_progressBar.setValue(0)

        # URLs
        # buildings
        url_buildings = 'https://www.opengeodata.nrw.de/produkte/umwelt_klima/klima/kwp/'

        # parcels
        url_parcels = 'https://www.wfs.nrw.de/geobasis/wfs_nw_inspire-flurstuecke_alkis'
        layer_parcels = 'cp:CadastralParcel'

        # get name from combo box
        if self.dlg.load_radioButton_municipality.isChecked():
            name = self.dlg.load_comboBox_municipality.currentText()
            parameter = 'municipality'
        elif self.dlg.load_radioButton_city.isChecked():
            name = self.dlg.load_comboBox_city.currentText()
            parameter = 'city'
        else:
            self.dlg.load_label_feedback.setText('please choose municipality or city')
            return
        
        # update progressBar
        self.dlg.load_progressBar.setValue(1)
        
        
        # filter df for city/municipality name
        filtered_df = filter_df(name, self.gemarkungen_df, parameter)
        
        # city/municipality keys
        municipality_key = filtered_df['gmdschl'][0]

        # update progressBar
        self.dlg.load_progressBar.setValue(5)
        self.dlg.load_label_feedback.setStyleSheet("color: orange")
        self.dlg.load_label_feedback.setText('Downloading...')
        self.dlg.load_label_feedback.repaint()

        # buildings shapes
        all_buildings_files = file_list_from_URL(url_buildings+'index.json')
        self.dlg.load_progressBar.setValue(10)
        buildings_zip = search_filename(all_buildings_files, municipality_key)
        self.dlg.load_progressBar.setValue(15)
        buildings_file_pattern = f'WBM-NRW_{municipality_key}' # file pattern maybe has to be renamed, when changes on the website occur
        buildings_gdf = read_file_from_zip(url_buildings, buildings_zip, buildings_file_pattern)

        # update progressBar
        self.dlg.load_progressBar.setValue(35)

        # streets shapes
        streets_file_pattern = f'WBM-NRW-Waermelinien_{municipality_key}' # file pattern maybe has to be renamed, when changes on the website occur
        streets_gdf = read_file_from_zip(url_buildings, buildings_zip, streets_file_pattern)

        # update progressBar
        self.dlg.load_progressBar.setValue(55)

        # parcels
        gdf_list_parcels=[] # if a whole municipality is selected filtered df consists of multiple cities which parcels will be saved in this list and later merged
        for row  in filtered_df.itertuples():
            bbox = row.bbox
            key = row.schluessel
            parcel_gdf_i, e = get_shape_from_wfs(url_parcels, key, bbox, layer_parcels)
            if e == 1:
                self.dlg.load_label_feedback.setText(f'Too many parcels for key: {key}!\nMax. 100.000 parcels can be downloaded at once\nparcels incomplete')
            gdf_list_parcels.append(parcel_gdf_i)
        parcels_gdf = pd.concat(gdf_list_parcels, ignore_index=True)

        # update progressBar
        self.dlg.load_progressBar.setValue(90)

        # buffer(0) can sometimes repair invalid geometries
        buildings_gdf['geometry'] = buildings_gdf['geometry'].buffer(0)
        parcels_gdf['geometry'] = parcels_gdf['geometry'].buffer(0)

        # The buildings and streets can only be downloaded at municipality level, if you only want one city, the 
        # additional buildings are superfluous and only extend the calculation time of the following programs.
        # Therefore, only buildings that are located on the parcels that are available at municipality level are retained
        if parameter == 'city':
            union = gpd.GeoDataFrame(geometry=[parcels_gdf.unary_union])
            buildings_gdf = gpd.sjoin(buildings_gdf, union, predicate='intersects')
            streets_gdf = gpd.sjoin(streets_gdf, union, predicate='intersects')

        # update progressBar
        self.dlg.load_progressBar.setValue(98)

        # path to save net shape file and results
        buildings_path = self.dlg.load_lineEdit_buildings.text()
        streets_path = self.dlg.load_lineEdit_streets.text()
        parcels_path = self.dlg.load_lineEdit_parcels.text()

        # save shapes
        buildings_gdf.to_file(buildings_path)
        streets_gdf.to_file(streets_path)
        parcels_gdf.to_file(parcels_path)

        # load layers to project
        self.add_shapefile_to_project(parcels_path, style = 'parcels', group_name='Basic Data')
        self.add_shapefile_to_project(buildings_path, style = 'buildings', group_name='Basic Data')
        self.add_shapefile_to_project(streets_path, style = 'streets', group_name='Basic Data')
        
        # update progressBar
        self.dlg.load_progressBar.setValue(100)
        self.dlg.load_label_feedback.setStyleSheet("color: rgb(0, 255, 0)")
        self.dlg.load_label_feedback.setText('Download complete!')

    def adjust_files(self):
        '''
        Adjust and process building, street, and parcel data layers in a GIS project.

        This method performs several operations on geospatial data, including:
        
        1. **Initialization**:
        - Sets the initial value of the progress bar and provides feedback to the user interface.

        2. **Parameter Definitions**:
        - Defines the heat demand attribute (`heat_att`) and building age class bins (`bak_bins`) and labels (`bak_labels`).

        3. **Data Loading**:
        - Reads additional building information from an Excel file.

        4. **Layer Path and Object Retrieval**:
        - Retrieves file paths and layer objects for streets, buildings, and parcels from the selected options in the user interface.

        5. **Adjustment Class Initialization**:
        - Initializes instances of `Parcels_adj`, `Buildings_adj`, and `Streets_adj` classes for data processing.

        6. **Building Data Adjustments**:
        - **Heat Demand Filtering**: Filters out buildings without heat demand.
        - **Spatial Join**: Joins buildings with parcels to add building age information.
        - **Age Class Addition**: Adds building age classes and LANUV age and type information.
        - **Load Profile Addition**: Integrates load profiles from the Excel data.
        - **Data Cleanup**: Drops unwanted attributes and adds power information.
        - **ID Assignment**: Assigns new IDs to buildings and merges building data as needed.

        7. **Street Data Adjustments**:
        - Rounds street coordinates and adds a boolean column to indicate possible routes.

        8. **Saving and Layer Update**:
        - Determines whether to create new files or overwrite existing ones based on user input.
        - Saves the modified shapefiles and updates the QGIS project layers accordingly.

        9. **Completion**:
        - Finalizes the progress bar and provides completion feedback.

        Returns
        -------
        None
        '''
        # update progressBar
        self.dlg.adjust_progressBar.setValue(0)

        self.dlg.adjust_label_feedback.setStyleSheet("color: orange")
        self.dlg.adjust_label_feedback.setText('Calculating...')
        self.dlg.adjust_label_feedback.repaint()

        # heat demand attribute
        heat_att = 'RW_WW'

        # building age classes
        bak_bins = [0, 1918, 1948, 1957, 1968, 1978, 1983, 1994, 2001, 9999]
        bak_labels = ['B','C','D','E','F','G','H','I','J']
        
        excel_path = self.plugin_dir+'/data/building_info.xlsx'
        excel_building_info = pd.read_excel(excel_path, sheet_name='database')
        excel_building_demand = pd.read_excel(excel_path, sheet_name='Grunddaten_Gebaeude', nrows=13, usecols='A:D')

        streets_path, streets_layer_name, streets_layer_obj = self.get_layer_path_from_combobox(self.dlg.adjust_comboBox_streets)
        buildings_path, buildings_layer_name, buildings_layer_obj = self.get_layer_path_from_combobox(self.dlg.adjust_comboBox_buildings)
        parcels_path, parcels_layer_name, parcels_layer_obj  = self.get_layer_path_from_combobox(self.dlg.adjust_comboBox_parcels)
        print(parcels_path)
        # update progressBar
        self.dlg.adjust_progressBar.setValue(5)

        parcels = Parcels_adj(parcels_path)
        buildings = Buildings_adj(buildings_path, heat_att)
        streets = Streets_adj(streets_path)

        # test if buildings already have been adjusted
        if 'Lastprofil' in buildings.gdf.columns:
            self.dlg.adjust_progressBar.setValue(100) # update progressBar
            self.dlg.adjust_label_feedback.setStyleSheet("color: rgb(0, 255, 0)")
            self.dlg.adjust_label_feedback.setText('Buildings already adjusted!')
        else:
            buildings.gdf = buildings.gdf[buildings.gdf[heat_att]>0].reset_index(drop=True) # only buildings with heat demand
            self.dlg.adjust_progressBar.setValue(10) # update progressBar
            buildings.add_LANUV_age_and_type() # add building age and type by LANUV
            self.dlg.adjust_progressBar.setValue(20) # update progressBar
            buildings.merge_buildings()
            buildings.gdf['new_ID'] = buildings.gdf.index.astype('int32')
            self.dlg.adjust_progressBar.setValue(30) # update progressBar
            buildings.gdf = spatial_join(buildings.gdf.copy(), parcels.gdf, ['validFrom']) # building age from parcels
            self.dlg.adjust_progressBar.setValue(40) # update progressBar
            buildings.add_BAK(bak_bins,bak_labels) # add building age class
            self.dlg.adjust_progressBar.setValue(50) # update progressBar
            buildings.add_Vlh_Loadprofile(excel_building_info)
            self.dlg.adjust_progressBar.setValue(60) # update progressBar
            buildings.drop_unwanted()
            self.dlg.adjust_progressBar.setValue(70) # update progressBar
            buildings.add_power()
            buildings.add_custom_heat_demand(excel_building_demand)
            buildings.add_connect_option()

            self.dlg.adjust_progressBar.setValue(80) # update progressBar

            streets.round_streets()
            self.dlg.adjust_progressBar.setValue(90) # update progressBar
            streets.add_bool_column() # possible routes

            self.dlg.adjust_progressBar.setValue(95) # update progressBar

            if self.dlg.adjust_radioButton_new.isChecked():
                buildings_path = self.dlg.adjust_lineEdit_buildings.text()
                streets_path = self.dlg.adjust_lineEdit_streets.text()

            # save shapes
            buildings.gdf.to_file(buildings_path)
            streets.gdf.to_file(streets_path)

            # check if files are overwritten or newly created
            if self.dlg.adjust_radioButton_new.isChecked():
                self.add_shapefile_to_project(streets_path, style='streets_adj', group_name='Adjusted Files')
                self.add_shapefile_to_project(buildings_path, style='buildings_adj', group_name='Adjusted Files')
            else:
                QgsProject.instance().removeMapLayer(buildings_layer_obj)
                QgsProject.instance().removeMapLayer(streets_layer_obj)
                self.add_shapefile_to_project(streets_path, style = 'streets', group_name='Adjusted Files')
                self.add_shapefile_to_project(buildings_path, style = 'buildings', group_name='Adjusted Files')
            
            self.dlg.adjust_progressBar.setValue(100) # update progressBar

            self.dlg.adjust_label_feedback.setStyleSheet("color: rgb(0, 255, 0)")
            self.dlg.adjust_label_feedback.setText('Completed!')
            self.dlg.adjust_label_feedback.repaint()

    def status_analysis(self):
        '''
         Perform a status analysis of building and street data, updating the GIS project with new attributes and geometries.

        This method conducts an analysis that involves the following steps:

        1. **Progress Bar Initialization**:
        - Sets the initial value of the progress bar to indicate the start of the process.

        2. **Layer Path Retrieval**:
        - Retrieves paths and layer objects for streets, parcels, and buildings from the respective combo boxes in the user interface.

        3. **Attribute Selection**:
        - Retrieves the selected heat and power attributes from the combo boxes.

        4. **Output Path Specification**:
        - Specifies the file path for saving the polygon data from a line edit field.

        5. **Geospatial Data Loading**:
        - Reads the shapefiles for streets, parcels, and buildings into GeoDataFrames.

        6. **Warmth Load Density (WLD) Calculation**:
        - Initializes a `WLD` object with the loaded buildings and streets.
        - Calculates the centroid for buildings.
        - Identifies the closest street to each building.
        - Adds the length of connections between buildings and streets.
        - Adds the specified heat attribute and calculates the Warmth Load Density (WLD).
        - Updates the streets GeoDataFrame with the new attributes and saves it back to a shapefile.
        - Adds the updated street layer to the GIS project with a specific style.

        7. **Polygon Processing**:
        - Initializes a `Polygons` object with the parcels, updated streets, and buildings.
        - Selects parcels based on their connection to buildings within a specified distance.
        - Applies a buffer, dissolve, and explode operation to refine the polygon geometries.
        - Adds the specified heat and power attributes to the polygons.
        - Saves the processed polygons to a shapefile.
        - Adds the updated polygon layer to the GIS project with a specific style.

        8. **Completion**:
        - Updates the progress bar to indicate the completion of the analysis.

        Returns
        -------
        None
        '''
        # update progressBar
        self.dlg.status_progressBar.setValue(0)

        # feedback
        self.dlg.status_label_response.setText('Calculating...')
        self.dlg.status_label_response.setStyleSheet("color: orange")
        self.dlg.status_label_response.repaint()

        # layer from combo box
        streets_path, streets_layer_name, streets_layer_obj = self.get_layer_path_from_combobox(self.dlg.status_comboBox_streets)
        parcels_path, parcels_layer_name, parcels_layer_obj = self.get_layer_path_from_combobox(self.dlg.status_comboBox_parcels)
        buildings_path, buildings_layer_name, buildings_layer_obj = self.get_layer_path_from_combobox(self.dlg.status_comboBox_buildings)
        
        # attributes from layer
        heat_attribute = self.dlg.status_comboBox_heat.currentText()
        power_attribute = self.dlg.status_comboBox_power.currentText()

        # path from lineEdit
        polygon_path = self.dlg.status_lineEdit_polygons.text()

        self.dlg.status_progressBar.setValue(2) # update progressBar

        # shapes to gdf
        streets = gpd.read_file(streets_path)
        parcels = gpd.read_file(parcels_path)
        buildings = gpd.read_file(buildings_path)

        # HLD/WLD
        wld = WLD(buildings,streets)
        self.dlg.status_progressBar.setValue(5) # update progressBar
        wld.get_centroid()
        self.dlg.status_progressBar.setValue(20) # update progressBar
        wld.closest_street_buildings()
        self.dlg.status_progressBar.setValue(30) # update progressBar
        wld.add_lenght()
        self.dlg.status_progressBar.setValue(40) # update progressBar
        wld.add_heat_att(heat_att=heat_attribute)
        self.dlg.status_progressBar.setValue(50) # update progressBar
        wld.add_WLD(heat_att=heat_attribute)
        self.dlg.status_progressBar.setValue(60) # update progressBar
        wld.streets.to_file(streets_path)
        self.add_shapefile_to_project(streets_path, style = 'hld', group_name = 'Heat Density')
        

        # polygons
        polygons = Polygons(parcels, wld.streets, buildings)
        polygons.select_parcels_by_building_connection(0.1)
        self.dlg.status_progressBar.setValue(70) # update progressBar
        polygons.buffer_dissolve_and_explode(0.5)
        self.dlg.status_progressBar.setValue(80) # update progressBar
        polygons.add_attributes(heat_attribute, power_attribute)
        self.dlg.status_progressBar.setValue(90) # update progressBar
        polygons.polygons.to_file(polygon_path)
        self.add_shapefile_to_project(polygon_path, style = 'polygons', group_name = 'Heat Density')
        self.dlg.status_progressBar.setValue(100) # update progressBar

        # feedback
        self.dlg.status_label_response.setStyleSheet("color: rgb(0, 255, 0)")
        self.dlg.status_label_response.setText('Completed!')
        self.dlg.status_label_response.repaint()

    def network_analysis(self):
        '''
        Conduct a network analysis for a district heating system, including setup, data loading,
        and computation of the optimal network path based on building heat demand and street layout.

        This method performs the following steps:

        1. **Progress Bar Initialization**:
        - Initializes the progress bar to indicate the start of the analysis.

        2. **User Feedback**:
        - Displays an initial status message indicating that calculations are in progress.

        3. **Load Pipe Data**:
        - Loads pipe data from an Excel file for use in the network analysis.

        4. **Retrieve Temperatures**:
        - Retrieves supply and return temperatures from SpinBoxes in the user interface.

        5. **Retrieve Layer Paths**:
        - Retrieves the file paths and objects for source, streets, and buildings layers from combo boxes.

        6. **Select Attributes**:
        - Retrieves the selected heat and power attributes from combo boxes.

        7. **Specify Output Path**:
        - Retrieves the path for saving the resulting network shapefile from a line edit field.

        8. **Progress Bar Update**:
        - Updates the progress bar to reflect the completion of data retrieval steps.

        9. **Instantiate Classes**:
        - Creates instances of classes for buildings, source, and streets, loading the respective data.

        10. **Polygon Filtering**:
            - If a polygon is selected, filters buildings to those within the polygon boundaries.

        11. **Drop Unwanted Routes**:
            - Removes street segments marked as not possible routes, if the attribute exists.

        12. **Create Connection Points**:
            - Adds centroids to buildings and finds closest points to streets.
            - Establishes connection points for sources to the street network.

        13. **Graph Construction**:
            - Constructs a network graph based on street geometry.
            - Connects building centroids and source points to the graph.
            - Adds edge attributes, such as length, to the graph.

        14. **Connectivity Check**:
            - Verifies that all points in the network are connected.
            - If not, provides feedback and visualization to assist in fixing disconnections.

        15. **Progress Bar Update**:
            - Updates the progress bar after constructing the graph.

        16. **Network Analysis**:
            - Creates a `Net` object and performs a detailed network analysis, computing the optimal network for heat distribution based on the supply and return temperatures, pipe data, and building attributes.

        17. **GeoDataFrame Creation and Saving**:
            - Converts the graph to a GeoDataFrame with the computed network.
            - Saves the GeoDataFrame as a shapefile at the specified output path.

        18. **Add Layer to Project**:
            - Adds the resulting network shapefile as a layer in the GIS project.

        19. **Completion**:
            - Finalizes the progress bar and provides user feedback indicating the successful completion of the network analysis.

        20. **Error Handling**:
            - Logs any exceptions encountered during the process and exits gracefully.

        Returns
        -------
        None
        '''
        # update progressBar
        self.dlg.net_progressBar.setValue(0)

        # feedback
        self.dlg.net_label_response.setText('Calculating...')
        self.dlg.net_label_response.setStyleSheet("color: orange")
        self.dlg.net_label_response.repaint()

        # pipe info
        excel_file_path = Path(self.plugin_dir) / 'data/pipe_data.xlsx'
        pipe_info = pd.read_excel(excel_file_path, sheet_name='pipe_data')

        # Temperatures from SpinBox
        t_supply = self.dlg.net_doubleSpinBox_supply.value()
        t_return = self.dlg.net_doubleSpinBox_return.value()

        if t_supply <= t_return:
            # feedback
            self.dlg.net_label_response.setText('The return temperature has to be smaller than the supply temperature!')
            self.dlg.net_label_response.setStyleSheet("color: red")
            self.dlg.net_label_response.repaint()
            return

        # Layer paths
        source_path, source_layer, source_layer_obj = self.get_layer_path_from_combobox(self.dlg.net_comboBox_source)
        streets_path, streets_layer, streets_layer_obj = self.get_layer_path_from_combobox(self.dlg.net_comboBox_streets)
        buildings_path, buildings_layer, buildings_layer_obj = self.get_layer_path_from_combobox(self.dlg.net_comboBox_buildings)
        
        heat_attribute = self.dlg.net_comboBox_heat.currentText()
        power_attribute = self.dlg.net_comboBox_power.currentText()

        # path to save net shape file
        shape_path = self.dlg.net_lineEdit_net.text()

        # update progressBar
        self.dlg.net_progressBar.setValue(2)

        # Instantiate classes
        buildings = Buildings(buildings_path, heat_attribute, buildings_layer)
        source = Source(source_path, source_layer)
        streets = Streets(streets_path, streets_layer)
        
        # check if polygon checkbox is checked
        if self.dlg.net_checkBox_polygon.isChecked():
            polygon_path, polygon_layer, polygon_layer_obj  = self.get_layer_path_from_combobox(self.dlg.net_comboBox_polygon)
            # load polygon as gdf
            if polygon_layer == None:
                polygon = gpd.read_file(polygon_path)
            else: 
                polygon = gpd.read_file(polygon_path, layer=polygon_layer)

            # only buildings within polygon
            buildings.gdf = gpd.sjoin(buildings.gdf, polygon, how="inner", predicate="within")

        # Drop unwanted routes if existing
        try:
            streets.gdf = streets.gdf[streets.gdf['possible_route']==1]
        except:
            pass

        # Drop unconnected buildings if existing
        try:
            buildings.gdf = buildings.gdf[buildings.gdf['Anschluss']==1]
        except:
            pass

        # update progressBar
        self.dlg.net_progressBar.setValue(5)

        # create connection points
        buildings.add_centroid()
        buildings.closest_points_buildings(streets.gdf)
        source.closest_points_sources(streets.gdf)
        streets.add_connection_to_streets(buildings.gdf, source.gdf)

        # update progressBar
        self.dlg.net_progressBar.setValue(15)

        # Graph erstellen
        graph = Graph()
        graph.create_street_network(streets.gdf)
        graph.connect_centroids(buildings.gdf)
        graph.connect_source(source.gdf)
        graph.add_attribute_length()

        # test connection
        start_point = (source.gdf['geometry'][0].x, source.gdf['geometry'][0].y)
        connected_points = graph.get_connected_points(start_point)
        all_points = list(graph.graph.nodes)
        if start_point not in connected_points:
            connected_points.append(start_point)
        if len(all_points) > len(connected_points):
            print(len(all_points), len(connected_points))
            # check if polygon is activated
            if self.dlg.net_checkBox_polygon.isChecked():
                # check if disconnected points are inside the polygon
                disconnected_points = [point for point in all_points if point not in connected_points and point != start_point]
                print( f'disconnected nodes: {len(disconnected_points)}')
                print(disconnected_points)
                if any(polygon['geometry'][0].contains(Point(point)) for point in disconnected_points):
                    # feedback
                    self.dlg.net_label_response.setText('Some points of the street network in your area are not connected! Please set their "possible_route"-attribute to zero or connect them to the street network by using the snapping tool.')
                    self.dlg.net_label_response.setStyleSheet("color: red")
                    self.dlg.net_label_response.repaint()
                    graph.plot_graph(start_point, connected_points)
                    raise RuntimeError("Some points of the street network in your area are not connected!")
            else:
                disconnected_points = [point for point in all_points if point not in connected_points and point != start_point]
                print( f'{len(disconnected_points)} disconnected nodes')
                print(disconnected_points)
                # feedback
                self.dlg.net_label_response.setText('Some points of the street network are not connected! Please set their "possible_route"-attribute to zero or connect them to the street network by using the snapping tool.')
                self.dlg.net_label_response.setStyleSheet("color: red")
                self.dlg.net_label_response.repaint()
                graph.plot_graph(start_point, connected_points)
                raise RuntimeError("Some points of the street network are not connected!")

        # update progressBar
        self.dlg.net_progressBar.setValue(30)


        ### Net Analysis ###
        net = Net(t_supply,t_return)
        net.network_analysis(graph.graph, buildings.gdf, source.gdf, pipe_info, power_att=power_attribute, progressBar=self.dlg.net_progressBar)

        # update progressBar
        self.dlg.net_progressBar.setValue(45)

        # GeoDataFrame from net
        net.ensure_power_attribute()
        net.graph_to_gdf(crs = buildings.gdf.crs)
        
        # save net shape
        net.gdf.to_file(shape_path)

        # load net as layer
        self.add_shapefile_to_project(shape_path, 'net', group_name='Net')

        # update progressBar
        self.dlg.net_progressBar.setValue(100)
        # feedback
        self.dlg.net_label_response.setText('Completed')
        self.dlg.net_label_response.setStyleSheet("color: rgb(0, 255, 0)")
        self.dlg.net_label_response.repaint()

    def create_result(self):
        '''
        Generate and save the results of the network analysis, including a detailed
        energy demand profile and associated data for a district heating system.

        This method performs the following steps:

        1. **Progress Bar Initialization**:
        - Sets the progress bar to 0, indicating the start of the result creation process.

        2. **User Feedback**:
        - Displays an initial status message indicating that calculations are in progress.

        3. **Load Pipe Data**:
        - Loads pipe information from an Excel file, including pipe diameters (DN).

        4. **Define Load Profiles**:
        - Sets the load profiles for different building types (e.g., EFH, MFH).

        5. **Retrieve Temperature Values**:
        - Retrieves the supply and return temperatures from the user interface.

        6. **Retrieve Layer Paths**:
        - Gets file paths and objects for source, streets, and buildings layers from combo boxes.

        7. **Select Attributes**:
        - Retrieves selected heat and power attributes from the user interface.

        8. **Load Network Shapefile**:
        - Loads the network data from the specified shapefile path.

        9. **Instantiate Classes**:
        - Creates instances of relevant classes for buildings, source, and streets.

        10. **Polygon Filtering**:
            - If a polygon is selected, filters buildings to include only those within the polygon boundaries.

        11. **Progress Bar Update**:
            - Updates the progress bar after loading and preparing data.

        12. **Create Result Data Structure**:
            - Initializes the `Result` class and prepares a data dictionary from the buildings and network data.

        13. **Generate DataFrame**:
            - Converts the data dictionary into a DataFrame and saves it as an Excel file.

        14. **Load Curve Generation**:
            - If a temperature file is provided, loads the temperature data; otherwise, retrieves historical temperature data from an external source.

        15. **Energy Demand Profile Creation**:
            - Creates a time series DataFrame for energy demand based on load profiles, temperature data, and building heat demand.

        16. **Aggregate Demand and Losses**:
            - Adds a column for the sum of all buildings' demands and calculates losses. 
            - Adds a total column that includes both the demand and losses.

        17. **Visualization**:
            - Plots and saves bar charts for the energy demand profile and sorted demand profile.

        18. **Save and Embed Results**:
            - Saves the demand profile in an Excel file and embeds the generated plots as images.

        19. **Open Result File**:
            - Opens the resulting Excel file for user review.

        20. **Completion**:
            - Updates the progress bar to 100% and displays a completion message to the user.

        Returns
        -------
        None
        '''
        # update progressBar
        self.dlg.net_progressBar.setValue(0)

        # feedback
        self.dlg.net_label_response.setText('Calculating...')
        self.dlg.net_label_response.setStyleSheet("color: orange")
        self.dlg.net_label_response.repaint()

        # pipe info
        excel_file_path = Path(self.plugin_dir) / 'data/pipe_data.xlsx'
        pipe_info = pd.read_excel(excel_file_path, sheet_name='pipe_data')
        dn_list = pipe_info['DN'].to_list()

        # Load Profiles
        load_profiles = ['EFH', 'MFH', 'GHA', 'GMK', 'GKO']

        # Temperatures from SpinBox
        t_supply = self.dlg.net_doubleSpinBox_supply.value()
        t_return = self.dlg.net_doubleSpinBox_return.value()

        # Layer paths
        source_path, source_layer, source_layer_obj = self.get_layer_path_from_combobox(self.dlg.net_comboBox_source)
        streets_path, streets_layer, streets_layer_obj = self.get_layer_path_from_combobox(self.dlg.net_comboBox_streets)
        buildings_path, buildings_layer, buildings_layer_obj = self.get_layer_path_from_combobox(self.dlg.net_comboBox_buildings)
        
        heat_attribute = self.dlg.net_comboBox_heat.currentText()
        power_attribute = self.dlg.net_comboBox_power.currentText()

        # net path
        net_path = self.dlg.net_lineEdit_net.text()
        net_gdf = gpd.read_file(net_path)

        # Instantiate classes
        buildings = Buildings(buildings_path, heat_attribute, buildings_layer)
        source = Source(source_path, source_layer)
        streets = Streets(streets_path, streets_layer)
        
        # check if polygon checkbox is checked
        if self.dlg.net_checkBox_polygon.isChecked():
            polygon_path, polygon_layer, polygon_layer_obj  = self.get_layer_path_from_combobox(self.dlg.net_comboBox_polygon)
            # load polygon as gdf
            if polygon_layer == None:
                polygon = gpd.read_file(polygon_path)
            else:
                polygon = gpd.read_file(polygon_path, layer=polygon_layer)

            # only buildings within polygon
            buildings.gdf = gpd.sjoin(buildings.gdf, polygon, how="inner", predicate="within")

        # update progressBar
        self.dlg.net_progressBar.setValue(10)

        ### result ###
        result_path = self.dlg.net_lineEdit_result.text()
        result = Result(result_path)

        # copy result file to user path
        costs_path = Path(self.plugin_dir) / 'data/costs.xlsx'
        result.copy_excel_file(costs_path)

        result.create_data_dict(buildings.gdf, net_gdf, load_profiles, dn_list, heat_attribute, t_supply, t_return)
        result.create_df_from_dataDict(net_name = os.path.splitext(os.path.basename(net_path))[0])
        
        # save result
        result.save_in_excel(result_table = result.gdf)

        # update progressBar
        self.dlg.net_progressBar.setValue(15)

        ### building statistic ###
        statistic = result.building_statistic(buildings.gdf)
        result.save_in_excel(result_table = statistic, sheet = 'Statistik')
    
        # update progressBar
        self.dlg.net_progressBar.setValue(20)

        ### Load Curve ###

        ## temperature
        if self.dlg.net_checkBox_temperature.isChecked():
            temp_path = self.dlg.net_lineEdit_temperature.text()
            temp_profile = pd.read_excel(temp_path)
        else:
            # poi = (source.gdf['geometry'][0].x, source.gdf['geometry'][0].y) # Point of interest
            # n = 5  # number of years for mean value
            # url_temp = 'https://opendata.dwd.de/climate_environment/CDC/observations_germany/climate/hourly/air_temperature/historical/'

            # temp = Temperature(url_temp)
            # stations = temp.stationsfromtxt()
            # station = temp.nearestStation(poi,stations,n)
            # station_id = station['Stations_id'][0]
            # station_name = station['Stationsname'][0]
            # start_date = station['von_datum'][0]
            # end_date = station['bis_datum'][0]
            # average_temp_profile = temp.tempdata(temp.url, station_id, start_date, end_date, n)

            # if self.dlg.net_checkBox_save_temp.isChecked():
            #     save_path = self.dlg.net_lineEdit_save_temp.text()
            #     average_temp_profile['Station_ID'] = station_id
            #     average_temp_profile['Station_Name'] = station_name
            #     safe_in_excel(save_path, average_temp_profile, sheet = 'Temperature_Data')
            temp_path = Path(self.plugin_dir) / 'data/example_temperature.xlsx'
            temp_profile = pd.read_excel(temp_path)

        # update progressBar
        self.dlg.net_progressBar.setValue(25)

        ## load curve

        # set up time data
        year = 2022
        resolution = 8760
        freq = 'H'

        # Holidays
        cal = Germany()
        holidays = dict(cal.holidays(year))

        # temperature
        temperature_data = temp_profile['TT_TU']

        # load_profile class
        load_profile = LoadProfile(result.gdf, result_path, year, temperature_data, holidays)
        
        # dataframe for collecting generated profiles
        demand = load_profile.set_up_df(year, resolution, freq)

        # update progressBar
        self.dlg.net_progressBar.setValue(30)

        for row in load_profile.net_result.itertuples(index=False):
            building_type = row.Lastprofil
            building_class = 3 # Baualtersklasse NRW:3 Quelle:Praxisinformation P 2006 / 8 Gastransport / Betriebswirtschaft, BGW, 2006, Seite 43 Tabelle 2 und 3
            if pd.isna(building_type):
                break
            elif building_type.lower() not in ('efh', 'mfh'):
                building_class = 0
            hd = row[2]
            demand[building_type] = load_profile.create_heat_demand_profile(building_type, building_class, 0, 1, hd)

        # update progressBar
        self.dlg.net_progressBar.setValue(35)

        # add sum column for all buildings
        demand_with_sum_buildings = load_profile.add_sum_buildings(demand)

        # add Gleichzeitigkeitsfaktor/coincident factor to demand
        # glf = result.data_dict['GLF'][0] # Gleichzeitigkeitsfaktor/coincident factor
        # demand_glf = load_profile.add_glf(demand_with_sum_buildings,glf)

        # add loss
        demand_with_loss = load_profile.add_loss(demand_with_sum_buildings, load_profile.net_result, resolution)
        
        # add sum buildings+loss
        demand_with_sum = load_profile.add_sum(demand_with_loss)

        # update progressBar
        self.dlg.net_progressBar.setValue(40)

        # plot and save fig
        load_profile.plot_bar_chart(demand_with_sum, column_names=['Gesamtsumme', 'Verlust'], filename = self.project_dir+'/Lastprofil.png')
        # update progressBar
        self.dlg.net_progressBar.setValue(50)
        load_profile.plot_bar_chart(demand_with_sum, column_names=['Gesamtsumme (extra Dämmung)', 'Verlust'], colors=['green','orange'], filename = self.project_dir+'/Lastprofil_extra_Daemmung.png', ylabel='Wärmebedarf und Verlust bei extra Dämmung [MW]', title='Wärmebedarf und Verlust bei extra Dämmung pro Stunde im Jahr')

        # update progressBar
        self.dlg.net_progressBar.setValue(60)

        # order
        sorted_demand = demand_with_sum.sort_values(by='Gesamtsumme', ascending=False)

        # plot and save fig
        load_profile.plot_bar_chart(sorted_demand, column_names=['Gesamtsumme', 'Verlust'], filename = self.project_dir+'/Lastprofil_geordnet.png', title='Geordnetes Lastprofil')

        # update progressBar
        self.dlg.net_progressBar.setValue(70)

        # order extra insulation
        sorted_demand = demand_with_sum.sort_values(by='Gesamtsumme (extra Dämmung)', ascending=False)

        # plot and save fig extra insulation
        load_profile.plot_bar_chart(sorted_demand, column_names=['Gesamtsumme (extra Dämmung)', 'Verlust'], colors=['green','orange'], filename = self.project_dir+'/Lastprofil_extra_Daemmung_geordnet.png', ylabel='Wärmebedarf und Verlust bei extra Dämmung [MW]', title='Geordnetes Lastprofil (extra Dämmung)')

        # update progressBar
        self.dlg.net_progressBar.setValue(80)

        # round columns of demand dataframe
        demand_with_sum = demand_with_sum.round(decimals=3)

        # save demand profile in excel
        load_profile.save_in_excel(demand_with_sum, index_bool=True)

        # save load curve plot in excel
        load_profile.embed_image_in_excel(0,demand_with_sum.shape[1]+1, image_filename = self.project_dir+'/Lastprofil.png')

        # save sorted load curve plot in excel
        load_profile.embed_image_in_excel(22,demand_with_sum.shape[1]+1, image_filename = self.project_dir+'/Lastprofil_geordnet.png')

        # save load curve plot in excel extra insulation
        load_profile.embed_image_in_excel(44,demand_with_sum.shape[1]+1, image_filename = self.project_dir+'/Lastprofil_extra_Daemmung.png')

        # save sorted load curve plot in excel extra insulation
        load_profile.embed_image_in_excel(66,demand_with_sum.shape[1]+1, image_filename = self.project_dir+'/Lastprofil_extra_Daemmung_geordnet.png')

        # open result
        load_profile.open_excel_file()

        # update progressBar
        self.dlg.net_progressBar.setValue(100)
        # feedback
        self.dlg.net_label_response.setText('Completed')
        self.dlg.net_label_response.setStyleSheet("color: rgb(0, 255, 0)")
        self.dlg.net_label_response.repaint()

    def run(self):
        """Run method that performs all the real work"""

        # Project path
        project_file_path = QgsProject.instance().fileName()
        self.project_dir = os.path.dirname(project_file_path)

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = HeatNetToolDialog()

            # check modules
            try:
                import pandas as pd
                import geopandas as gpd
                from shapely import Point
                from .src.download_files import file_list_from_URL, search_filename, read_file_from_zip, filter_df, get_shape_from_wfs
                from .src.adjust_files import Streets_adj, Buildings_adj, Parcels_adj, spatial_join
                from .src.status_analysis import WLD, Polygons
                from .src.net_analysis import Streets, Source, Buildings, Graph, Net, Result, get_closest_point, calculate_GLF, calculate_volumeflow, calculate_diameter_velocity_loss
                from .src.load_curve import Temperature, LoadProfile, safe_in_excel
                from workalendar.europe import Germany
            except Exception as e:
                message_box = QMessageBox()
                message_box.setIcon(QMessageBox.Warning)
                message_box.setWindowTitle('Import Error')
                message_box.setText(f'Failed to import a required module: {str(e)}')
                message_box.setInformativeText('Please install all required Python packages by pressing "Install Packages" in the Introduction part of the F|Heat plugin.')
                message_box.exec_()

            # install python packages
            self.dlg.intro_pushButton_load_packages.clicked.connect(lambda: self.install_package())

            ### Load ###

            # download options
            self.load_download_options()
            
            # shape paths
            self.dlg.load_pushButton_buildings.clicked.connect(
                lambda: self.select_output_file(self.project_dir, self.dlg.load_lineEdit_buildings,'*.gpkg;;*.shp'))
            self.dlg.load_pushButton_parcels.clicked.connect(
                lambda: self.select_output_file(self.project_dir, self.dlg.load_lineEdit_parcels,'*.gpkg;;*.shp'))
            self.dlg.load_pushButton_streets.clicked.connect(
                lambda: self.select_output_file(self.project_dir, self.dlg.load_lineEdit_streets,'*.gpkg;;*.shp'))
            
            # Start Download Files 
            self.dlg.load_pushButton_start.clicked.connect(self.download_files)

            ### Adjust ###

            # shape paths
            self.dlg.adjust_pushButton_buildings.clicked.connect(
                lambda: self.select_output_file(self.project_dir, self.dlg.adjust_lineEdit_buildings,'*.gpkg;;*.shp'))
            self.dlg.adjust_pushButton_streets.clicked.connect(
                lambda: self.select_output_file(self.project_dir, self.dlg.adjust_lineEdit_streets,'*.gpkg;;*.shp'))
            
            # Start Adjust Files 
            self.dlg.adjust_pushButton_start.clicked.connect(self.adjust_files)

            ### status ###

            # shape paths
            self.dlg.status_pushButton_polygons.clicked.connect(
                lambda: self.select_output_file(self.project_dir, self.dlg.status_lineEdit_polygons,'*.gpkg;;*.shp'))
            
            # start status analysis
            self.dlg.status_pushButton_start.clicked.connect(self.status_analysis)

            ### Net ###

            # select output file
            self.dlg.net_pushButton_net_output.clicked.connect(
                lambda: self.select_output_file(self.project_dir, self.dlg.net_lineEdit_net,'*.gpkg;;*.shp'))
            self.dlg.net_pushButton_result.clicked.connect(
                lambda: self.select_output_file(self.project_dir, self.dlg.net_lineEdit_result,'*.xlsx'))
            self.dlg.net_pushButton_temperature.clicked.connect(
                lambda: self.select_input_file(self.project_dir, self.dlg.net_lineEdit_temperature,'*.xlsx'))

            # start network analysis
            self.dlg.net_pushButton_start.clicked.connect(self.network_analysis)

            # create result file
            self.dlg.net_pushButton_create_result.clicked.connect(self.create_result)
        
        # Create F|Heat layer structure
        self.create_layer_tree_structure()

        # updates when tab is changed
        #self.dlg.tabWidget.currentChanged.connect(self.tab_change)

        # update the download options
        self.dlg.load_comboBox_municipality.currentIndexChanged.connect(self.adapt_download_options)

        # Connect signal for status_comboBox_buildings to load attributes on change
        self.dlg.status_comboBox_buildings.currentIndexChanged.connect(
            lambda: self.load_attributes('status_comboBox_buildings', 'status_comboBox_heat'))
        self.dlg.status_comboBox_buildings.currentIndexChanged.connect(
            lambda: self.load_attributes('status_comboBox_buildings', 'status_comboBox_power'))
        
        # Connect signal for net_comboBox_buildings to load attributes on change
        self.dlg.net_comboBox_buildings.currentIndexChanged.connect(
            lambda: self.load_attributes('net_comboBox_buildings', 'net_comboBox_heat'))
        self.dlg.net_comboBox_buildings.currentIndexChanged.connect(
            lambda: self.load_attributes('net_comboBox_buildings', 'net_comboBox_power'))

        # show the dialog
        self.dlg.show()